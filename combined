<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Laundry BLE Controller (Combined)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 0; background: #0f172a; color: #e2e8f0; }
    .wrap { max-width: 920px; margin: 0 auto; padding: 20px; }
    h1 { font-size: 1.2rem; margin: 0 0 10px; }
    .card { background: #111827; border: 1px solid #334155; border-radius: 14px; padding: 14px; margin: 12px 0; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; align-items: center; }
    button {
      border: 1px solid #475569; background: #1e293b; color: #e2e8f0;
      padding: 10px 12px; border-radius: 10px; font-size: 0.95rem;
      cursor: pointer;
    }
    button:hover { background: #273449; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    select, input {
      border: 1px solid #475569; background: #0b1220; color: #e2e8f0;
      padding: 10px 12px; border-radius: 10px; font-size: 0.95rem;
      outline: none;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .small { font-size: 0.85rem; color: #94a3b8; }
    .ok { color: #22c55e; }
    .warn { color: #f59e0b; }
    .bad { color: #ef4444; }
    .map { margin-top: 8px; padding: 10px; border: 1px dashed #475569; border-radius: 10px; background: #0b1220; }
    #log {
      white-space: pre-wrap;
      background: #020617;
      border: 1px solid #334155;
      padding: 12px;
      border-radius: 10px;
      max-height: 360px;
      overflow: auto;
    }
    .pill {
      display: inline-flex;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #334155;
      background: #0b1220;
      font-size: 0.85rem;
      color: #cbd5e1;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Laundry Controller Vanbrugh (Combined)</h1>

    <div class="card">
      <div class="row">
        <span class="pill">Project / Machine set</span>
        <select id="projectSelect"></select>

        <span class="pill">Optional device hint</span>
        <input id="hintInput" placeholder="e.g. AWD4697RXYR1 (just for your reference)" style="min-width:260px;" />
      </div>

      <div class="row">
        <button id="connectBtn">Connect Device</button>
        <button id="disconnectBtn" disabled>Disconnect</button>
      </div>

      <div class="small" id="status">Status: not connected</div>

      <div class="small mono" style="margin-top:10px;">
        Service UUID: 569a1101-b87f-490c-92cb-11ba5ea5167c<br>
        RX UUID: 569a2000-b87f-490c-92cb-11ba5ea5167c<br>
        TX UUID: 569a2001-b87f-490c-92cb-11ba5ea5167c
      </div>

      <div class="map small" id="deviceMap">
        <strong>When selecting a device:</strong><br>
      </div>

      <div class="small" style="margin-top:10px;">
        Tip: In the chooser, pick the BLE name shown above for the machine you want.
      </div>
    </div>

    <div class="card">
      <div class="row" id="machineButtons"></div>
    </div>

    <div class="card">
      <strong>Log</strong>
      <div id="log" class="mono"></div>
    </div>
  </div>

  <script>
    // ============================================================
    // 1) COMBINED CONFIG: BOTH OF YOUR PROJECTS IN ONE FILE
    // ============================================================
    // Add more "projects" if you want to group machines by room/building/etc.
    const PROJECTS = [
      {
        id: "project_dryer3",
        name: "Dryer 3 set",
        machines: [
          {
            id: "dryer3",
            name: "Dryer 3",
            bluetoothName: "AW9RU7RZFZR1",
            password: "NVW537888",
            type: "dryer",
            cycles: { min15: "15 min cycle", full: "Full dry" }
          }
        ]
      },
      {
        id: "project_washer8",
        name: "Washer 8 set",
        machines: [
          {
            id: "washer8",
            name: "Washer 8",
            bluetoothName: "AWD4697RXYR1",
            password: "NZB175325",
            type: "washer",
            cycles: { full: "Full wash" }
          }
        ]
      }
    ];

    // Current selected project (default first)
    let activeProjectId = PROJECTS[0]?.id || "";
    function getActiveMachines() {
      return (PROJECTS.find(p => p.id === activeProjectId)?.machines) || [];
    }

    // ============================================================
    // 2) BLE UUIDs / COMMON COMMANDS
    // ============================================================
    const SERVICE_UUID = "569a1101-b87f-490c-92cb-11ba5ea5167c";
    const RX_UUID = "569a2000-b87f-490c-92cb-11ba5ea5167c"; // notify
    const TX_UUID = "569a2001-b87f-490c-92cb-11ba5ea5167c"; // write

    const CMD = {
      HANDSHAKE: "[HANDSHAKE:ENABLE]",
      VERSION: "[VERSION]",
      COIN_DISABLE: "[COIN:DISABLE:OCCUPIED_LOW]",
      EXEC: "[EXEC]",
    };

    // ============================================================
    // 3) MACHINE-SPECIFIC COMMAND BUILDERS
    // ============================================================
    function washerActivateFull(password) {
      return `[ACTIVATE:01:PULSE:OCCUPIED_LOW:00000000:00000032:00000032:0003:${password}]`;
    }
    function dryerActivateFull(password) {
      return `[ACTIVATE:01:PULSE:OCCUPIED_LOW:00000000:00000032:00000032:0004:${password}]`;
    }
    function dryerActivate15(password) {
      return `[ACTIVATE:01:PULSE:OCCUPIED_LOW:00000000:00000032:00:0001:${password}]`;
    }

    function getActivateCommand(machine, cycleKey) {
      if (machine.type === "washer") {
        if (cycleKey === "full") return washerActivateFull(machine.password);
      }
      if (machine.type === "dryer") {
        if (cycleKey === "full") return dryerActivateFull(machine.password);
        if (cycleKey === "min15") return dryerActivate15(machine.password);
      }
      throw new Error(`Unsupported cycle "${cycleKey}" for ${machine.type}`);
    }

    // ===== State =====
    let device = null;
    let server = null;
    let service = null;
    let rxChar = null;
    let txChar = null;

    let rxBuf = new Uint8Array(0);
    const msgQueue = [];
    let waiters = [];

    const enc = new TextEncoder();
    const dec = new TextDecoder("utf-8", { fatal: false });

    // ===== UI =====
    const els = {
      projectSelect: document.getElementById("projectSelect"),
      hintInput: document.getElementById("hintInput"),

      connectBtn: document.getElementById("connectBtn"),
      disconnectBtn: document.getElementById("disconnectBtn"),
      status: document.getElementById("status"),
      log: document.getElementById("log"),
      machineButtons: document.getElementById("machineButtons"),
      deviceMap: document.getElementById("deviceMap"),
    };

    const dynamicButtons = [];

    function log(text, cls = "") {
      const line = `[${new Date().toLocaleTimeString()}] ${text}\n`;
      if (cls) {
        const span = document.createElement("span");
        span.className = cls;
        span.textContent = line;
        els.log.appendChild(span);
      } else {
        els.log.appendChild(document.createTextNode(line));
      }
      els.log.scrollTop = els.log.scrollHeight;
      console.log(text);
    }

    function setStatus(text, cls = "") {
      els.status.className = "small " + cls;
      els.status.textContent = "Status: " + text;
    }

    function setConnectedUI(connected) {
      els.connectBtn.disabled = connected;
      els.disconnectBtn.disabled = !connected;
      for (const b of dynamicButtons) b.disabled = !connected;
    }

    function resetRx() {
      rxBuf = new Uint8Array(0);
      msgQueue.length = 0;
      waiters.forEach(w => clearTimeout(w.timer));
      waiters = [];
    }

    function concatU8(a, b) {
      const out = new Uint8Array(a.length + b.length);
      out.set(a, 0);
      out.set(b, a.length);
      return out;
    }

    function extractFrames(bufRef) {
      const frames = [];
      while (true) {
        const start = bufRef.indexOf("[".charCodeAt(0));
        if (start < 0) {
          rxBuf = new Uint8Array(0);
          return frames;
        }
        if (start > 0) {
          bufRef = bufRef.slice(start);
          rxBuf = bufRef;
        }
        const end = bufRef.indexOf("]".charCodeAt(0), 1);
        if (end < 0) return frames;

        frames.push(bufRef.slice(0, end + 1));
        bufRef = bufRef.slice(end + 1);
        rxBuf = bufRef;
      }
    }

    function onNotify(event) {
      try {
        const v = event.target.value;
        const chunk = new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
        rxBuf = concatU8(rxBuf, chunk);

        for (const raw of extractFrames(rxBuf)) {
          const msg = dec.decode(raw);
          log(`RX: ${msg}`);
          enqueueMsg(msg);
        }
      } catch (e) {
        log(`[WARN] Notify parse error: ${String(e)}`, "warn");
      }
    }

    function enqueueMsg(m) {
      msgQueue.push(m);
      resolveWaiters();
    }

    function resolveWaiters() {
      if (!waiters.length || !msgQueue.length) return;
      for (let i = 0; i < waiters.length; i++) {
        const w = waiters[i];
        const idx = msgQueue.findIndex(m => m.startsWith(w.prefix));
        if (idx >= 0) {
          const [hit] = msgQueue.splice(idx, 1);
          clearTimeout(w.timer);
          w.resolve(hit);
          waiters.splice(i, 1);
          i--;
        }
      }
    }

    function waitForPrefix(prefix, timeoutMs = 8000) {
      const idx = msgQueue.findIndex(m => m.startsWith(prefix));
      if (idx >= 0) {
        const [hit] = msgQueue.splice(idx, 1);
        return Promise.resolve(hit);
      }
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          const i = waiters.findIndex(w => w.resolve === resolve);
          if (i >= 0) waiters.splice(i, 1);
          reject(new Error(`Timeout waiting for ${prefix}`));
        }, timeoutMs);
        waiters.push({ prefix, resolve, reject, timer });
      });
    }

    async function writeAscii(text) {
      if (!txChar) throw new Error("TX characteristic not ready");
      const bytes = enc.encode(text);

      try {
        await txChar.writeValueWithoutResponse(bytes);
      } catch {
        await txChar.writeValue(bytes);
      }
      log(`TX: ${text}`);
    }

    async function send(text, expectPrefix = null, timeoutMs = 8000) {
      await writeAscii(text);
      if (expectPrefix) return await waitForPrefix(expectPrefix, timeoutMs);
      return "";
    }

    async function runSequence(activateCmd) {
      try {
        await send(CMD.HANDSHAKE, "[ACK:HANDSHAKE]", 8000);
        await send(CMD.VERSION, "[VERSION:", 8000);
        await send(CMD.COIN_DISABLE, "[ACK:COIN]", 8000);
        await send(activateCmd, "[ACK:ACTIVATE]", 8000);
        await send(CMD.EXEC, "[ACK:EXEC]", 8000);
        await new Promise(r => setTimeout(r, 500));
        log("Result: SUCCESS", "ok");
      } catch (e) {
        log(`Result: FAILED - ${String(e)}`, "bad");
      }
    }

    async function connect() {
      log("[INFO] Connect clicked...");

      if (!window.isSecureContext) {
        log("[ERROR] Requires HTTPS or localhost", "bad");
        setStatus("requires HTTPS/localhost", "bad");
        return;
      }
      if (!navigator.bluetooth) {
        log("[ERROR] Web Bluetooth unsupported in this browser", "bad");
        setStatus("Web Bluetooth unsupported", "bad");
        return;
      }

      els.connectBtn.disabled = true;

      try {
        resetRx();
        setStatus("opening chooser...");

        // NOTE: Browser chooser filtering is limited; we keep acceptAllDevices=true.
        // You select the correct device by its BLE name (shown in the device map).
        device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: [SERVICE_UUID]
        });

        log(`[INFO] Chooser returned: ${device.name || "(unnamed)"} (${device.id || "no-id"})`);
        device.addEventListener("gattserverdisconnected", onDisconnected);

        setStatus("connecting gatt...");
        server = await device.gatt.connect();
        log("[INFO] GATT connected.", "ok");

        setStatus("getting service...");
        service = await server.getPrimaryService(SERVICE_UUID);
        log("[INFO] Primary service opened.", "ok");

        setStatus("getting tx characteristic...");
        txChar = await service.getCharacteristic(TX_UUID);
        log("[INFO] TX characteristic ready.", "ok");

        try {
          rxChar = await service.getCharacteristic(RX_UUID);
          await rxChar.startNotifications();
          rxChar.addEventListener("characteristicvaluechanged", onNotify);
          log("[INFO] RX notifications enabled.", "ok");
        } catch (e) {
          rxChar = null;
          log(`[WARN] RX notifications unavailable: ${String(e)}`, "warn");
        }

        setConnectedUI(true);
        setStatus(`connected to ${device.name || "(unnamed device)"}`, "ok");
      } catch (e) {
        log(`[ERROR] Connect failed: ${e?.name || "Error"}: ${e?.message || String(e)}`, "bad");
        setStatus("connect failed", "bad");
        await disconnect();
      } finally {
        if (!device || !device.gatt || !device.gatt.connected) {
          els.connectBtn.disabled = false;
        }
      }
    }

    async function disconnect() {
      try {
        if (rxChar) {
          try { rxChar.removeEventListener("characteristicvaluechanged", onNotify); } catch {}
          try { await rxChar.stopNotifications(); } catch {}
        }
        if (device && device.gatt && device.gatt.connected) {
          device.gatt.disconnect();
        }
      } finally {
        device = null;
        server = null;
        service = null;
        rxChar = null;
        txChar = null;
        resetRx();
        setConnectedUI(false);
        setStatus("not connected");
        log("[INFO] Disconnected.");
      }
    }

    function onDisconnected() {
      log("[WARN] Device disconnected.", "warn");
      device = null;
      server = null;
      service = null;
      rxChar = null;
      txChar = null;
      resetRx();
      setConnectedUI(false);
      setStatus("disconnected", "warn");
      els.connectBtn.disabled = false;
    }

    // ============================================================
    // 4) UI BUILDERS (RENDER FROM ACTIVE PROJECT)
    // ============================================================
    function renderProjectSelect() {
      els.projectSelect.innerHTML = "";
      for (const p of PROJECTS) {
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.name;
        els.projectSelect.appendChild(opt);
      }
      els.projectSelect.value = activeProjectId;
    }

    function renderDeviceMap() {
      const machines = getActiveMachines();
      const lines = ['<strong>When selecting a device:</strong><br>'];
      for (const m of machines) {
        lines.push(`Use <strong>${m.name}: ${m.bluetoothName}</strong><br>`);
      }
      els.deviceMap.innerHTML = lines.join("");
    }

    function renderMachineButtons() {
      const machines = getActiveMachines();
      els.machineButtons.innerHTML = "";
      dynamicButtons.length = 0;

      for (const machine of machines) {
        for (const [cycleKey, cycleLabel] of Object.entries(machine.cycles || {})) {
          const btn = document.createElement("button");
          btn.textContent = `${machine.name} - ${cycleLabel}`;
          btn.disabled = true;

          btn.addEventListener("click", async () => {
            try {
              const activateCmd = getActivateCommand(machine, cycleKey);
              log(`Starting ${machine.name}: ${cycleLabel}...`);
              await runSequence(activateCmd);
            } catch (e) {
              log(`[ERROR] ${machine.name} ${cycleLabel}: ${String(e)}`, "bad");
            }
          });

          els.machineButtons.appendChild(btn);
          dynamicButtons.push(btn);
        }
      }
    }

    function rerenderAll() {
      renderDeviceMap();
      renderMachineButtons();
      // Keep current connection state
      setConnectedUI(!!(device && device.gatt && device.gatt.connected));
      // Log the currently active set
      const machines = getActiveMachines();
      log(`[INFO] Active set: ${PROJECTS.find(p => p.id === activeProjectId)?.name || activeProjectId}`);
      for (const m of machines) log(`Use ${m.name} (${m.bluetoothName})`);
    }

    // ===== Handlers =====
    els.projectSelect.addEventListener("change", () => {
      activeProjectId = els.projectSelect.value;
      rerenderAll();
    });

    els.connectBtn.addEventListener("click", connect);
    els.disconnectBtn.addEventListener("click", disconnect);

    // ===== Init =====
    renderProjectSelect();
    rerenderAll();
    setConnectedUI(false);

    const ua = navigator.userAgent || "";
    if (ua.toLowerCase().includes("firefox")) {
      log("[WARN] Firefox detected. Use Chrome/Edge for Web Bluetooth.", "warn");
    }

    window.addEventListener("error", (e) => log(`[ERROR] Uncaught: ${e.message}`, "bad"));
    window.addEventListener("unhandledrejection", (e) => log(`[ERROR] Promise rejection: ${String(e.reason)}`, "bad"));
  </script>
</body>
</html>
